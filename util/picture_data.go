// Copyright 2016 Francisco Rodriguez. All rights reserved.
// Use of this source code is governed by The MIT license.

package util

import (
    "regexp"
    "strconv"
    
    "github.com/lucasb-eyer/go-colorful"
)

type pictureData struct {
    Width int
    Height int
    FontSize int
    Text string
    FGcolor string
    BGcolor string
    ImgType string
}

// BuildPictureData is used to "construct" the PictureData struct
// used to generate images. The vars variable this function takes
// in contains both the URL variables generated by Gorilla/mux
// and the "text" query string used to customize captions. 
func BuildPictureData(vars map[string]string) *pictureData {
    pd := new(pictureData)
    
    md := map[string]string{}
    
    // While these regexes operate similarly to the ones used on 
    // server.go, these ones do use named groups to do 
    // a more granular breakdown of data for the md array 
    re1 := regexp.MustCompile("(?P<Width>\\d+)(?:x)?(?P<Height>\\d+)?(?P<ImgType>\\.\\w+)?");
    re2 := regexp.MustCompile("^(?P<BGcolor>[\\da-f]+)(?P<ImgType>\\.\\w+)?");
    re3 := regexp.MustCompile("^(?P<FGcolor>[\\da-f]+)(?P<ImgType>\\.\\w+)?");
    
    breakdown(re1, vars["dimensions"], md)
    breakdown(re2, vars["bgcolor"], md)
    breakdown(re3, vars["fgcolor"], md)
    
    md["Text"] = vars["text"]
    
    // populate then takes care of handling things like string 
    // conversion and default settings for any unmapped values.
    pd.populate(md)
    
    return pd
}

func breakdown(re *regexp.Regexp, s string, md map[string]string) {
    names := re.SubexpNames()
    result := re.FindStringSubmatch(s)
    
    // If a regex result has a named group key on it,
    // assign it into our map.
    for k, v := range result {
        if k != 0 && v != "" {
            md[names[k]] = v
        }
    }
}

func (pd *pictureData) populate(md map[string]string) {
    
    // Set up the data in the user provided variables
    pd.Height, _ = strconv.Atoi(md["Height"])
    pd.Width, _ = strconv.Atoi(md["Width"])
    
    pd.BGcolor = colorFormat(md["BGcolor"])
    pd.FGcolor = colorFormat(md["FGcolor"])
    pd.Text = md["Text"]
    pd.ImgType = md["ImgType"]
    
    
    // Set up the default values of any unset pictureData values.
    pd.FontSize = pd.Height / 10
    
    if pd.Width == 0 {
        pd.Width = pd.Height
    }
    
    if pd.Text == "" {
        pd.Text = strconv.Itoa(pd.Height) + "x" + strconv.Itoa(pd.Width)
    }
    
    if pd.BGcolor == "" {
        pd.BGcolor = "CCCCCC"
    }
    
    // This one particular default setting is interesting
    // due to the use of the colorDifferential function.
    // We use it because if a user declares a background color that
    // is too similar to the default text color, we then would want 
    // to change the font color to something that's easier to read.
    if pd.FGcolor == "" && colorDifferential(pd.BGcolor, "969696") < 0.1 {
        pd.FGcolor = "A4A4A4"
    }
    
    if pd.FGcolor == "" {
        pd.FGcolor = "969696"
    }
    
    if pd.ImgType == "" {
        pd.ImgType = ".png"
    }
}

// I'm willing to bet theres a more elegant way to do this...
func colorFormat(s string) string {
    if len(s) == 3 {
        s = string([]byte{s[0],s[0],s[1],s[1],s[2],s[2]})
    }
    return s
}

// The value returned by this function will almost always be 
// between 0 and 1.
func colorDifferential(hex1 string, hex2 string) float64 {
    c1, _ := colorful.Hex("#"+hex1)
    c2, _ := colorful.Hex("#"+hex2)
    return c1.DistanceLab(c2)
}
